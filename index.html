
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>YaronYang&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="YaronYang">
    

    
    <meta name="description" content="A iOS Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="YaronYang's Blog">
<meta property="og:url" content="http://yaronyang.com/index.html">
<meta property="og:site_name" content="YaronYang's Blog">
<meta property="og:description" content="A iOS Developer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YaronYang's Blog">
<meta name="twitter:description" content="A iOS Developer">

    
    <link rel="alternative" href="/atom.xml" title="YaronYang&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="YaronYang&#39;s Blog" title="YaronYang&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="YaronYang&#39;s Blog">YaronYang&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yaronyang.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/17/Swift-4-0-该来的还是要来的/" title="Swift 4.0 该来的还是要来的" itemprop="url">Swift 4.0 该来的还是要来的</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-10-17T02:40:14.000Z" itemprop="datePublished"> Published 2016-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/README.md#development-major-version--swift-40" target="_blank" rel="external">https://github.com/apple/swift-evolution/blob/master/README.md#development-major-version--swift-40</a></p>
<h2 id="翻译跟自己的些理解"><a href="#翻译跟自己的些理解" class="headerlink" title="翻译跟自己的些理解"></a>翻译跟自己的些理解</h2><h1 id="Swift-Programming-Language-Evolution"><a href="#Swift-Programming-Language-Evolution" class="headerlink" title="Swift Programming Language Evolution"></a>Swift Programming Language Evolution</h1><p><strong>Before you initiate a pull request</strong>, please read the process document. Ideas should be thoroughly discussed on the <a href="https://swift.org/community/#swift-evolution" target="_blank" rel="external">swift-evolution mailing list</a> first.<br>在你进行合并请求前,请阅读进程文档,你的想法需要被大家在[swift-evolution mailing list]中讨论后,(你再提出合并请求.PS:很傲娇啊,别老是烦我)</p>
<p>This repository tracks the ongoing evolution of Swift. It contains:<br>这个仓库会跟踪SWift4.0的持续发展,它包括:</p>
<ul>
<li>Goals for upcoming Swift releases (this document).</li>
<li>马上就要发布的Swift版本变化的目标.</li>
<li>The <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="external">Swift evolution review status</a> tracking proposals to change Swift.</li>
<li>Swift新版本大家对他的评论以及改变状态.</li>
<li>The <a href="process.md">Swift evolution process</a> that governs the evolution of Swift.</li>
<li>Swift的演变与进化过程.</li>
<li><a href="commonly_proposed.md">Commonly Rejected Changes</a>, proposals which have been denied in the past.</li>
<li>经常被拒绝的修改方法与提案(PS:让你死的心服口服)</li>
</ul>
<p>This document describes goals for the Swift language on a per-release basis, usually listing minor releases adding to the currently shipping version and one major release out.  Each release will have many smaller features or changes independent of these larger goals, and not all goals are reached for each release.</p>
<p>Goals for past versions are included at the bottom of the document for historical purposes, but are not necessarily indicative of the features shipped. The release notes for each shipped version are the definitive list of notable changes in each release.<br>大致意思是会给出一个表,来描述每个大版本与每个小版本的改动目标,当然小版本的目标并不一定围绕当前大版本目标的指定,会有一些额外于主功能的小目标.<br>过去版本的目标会放在文档的底部,让你回顾历史.但并不代表说的一定精细,想看全的,你还是去哪个版本的文档查去吧.笑…</p>
<h2 id="Development-major-version-Swift-4-0"><a href="#Development-major-version-Swift-4-0" class="headerlink" title="Development major version:  Swift 4.0"></a>Development major version:  Swift 4.0</h2><h2 id="Swift开发主要版本-4-0"><a href="#Swift开发主要版本-4-0" class="headerlink" title="Swift开发主要版本 4.0"></a>Swift开发主要版本 4.0</h2><p>Expected release date: Late 2017<br><strong>发布时间会在2017年的后半年,年底?(这里偏向年底)</strong></p>
<p>The Swift 4 release is designed around two primary goals:<br>Swift 4.0 主要围绕两个设计目标:<br>to provide source stability for Swift 3 code and to provide ABI stability for the Swift standard library. To that end, the Swift 4 release will be divided into two stages.<br>1.为Swfit 3.0的代码提供稳定性<br>2.为Swift 的标准库提供二进制接口(ABI)稳定性<br>所以Swift4.0在两个阶段内完成.<br>Stage 1 focuses on the essentials required for source and ABI stability. Features that don’t fundamentally change the ABI of existing language features or imply an ABI-breaking change to the standard library will not be considered in this stage.</p>
<p>Stage 2 will commence once the implementation work on the Stage 1 features is cresting, and can contain a few other large and small features. We expect that stage 2 will commence some time in Spring 2017.</p>
<p>这段意思有点歧义我是这么理解的:<br>第一阶段:这段时间我们回侧重于源代码的稳定性于ABI的修改,会引入大量与现在不同或者说破坏现在稳定性的ABI来调整整个的结构.这意味着我们在接下来的时间里就不会再去破坏ABI的稳定性了.<br>第二阶段:第二阶段的开始时间定在第一阶段工作达到顶峰时,在不破坏ABI的稳定下,会存在大小特征的改变,这段工作会在2017年春季开始.</p>
<p>The high-priority features supporting stage 1’s source and ABI stability goals are:<br>第一阶段的最高优先级目标是:</p>
<ul>
<li>Source stability features: the Swift language will need <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md" target="_blank" rel="external">some                                                           accommodations</a> to support code bases that target different language versions, to help Swift deliver on its source-compatibility goals while still enabling rapid progress.</li>
<li><p>源稳定特性: Swift需要更好地拓展性来支持它面向不同语言版本,者能够帮助Swift在拥有兼容性的同时,实现快速开发.(也就是说可以2.3,3.0,OC,C,C++,一起搞开发了?)</p>
</li>
<li><p>Resilience: resilience provides a way for public APIs to evolve over time, while maintaining a stable ABI. For example, resilience eliminates the <a href="https://en.wikipedia.org/wiki/Fragile_base_class" target="_blank" rel="external">fragile base class                problem</a> that occurs in some object-oriented languages (e.g., C++) by describing the types of API changes that can be made without breaking ABI (e.g., “a new stored property or method can be added to a class”).</p>
</li>
<li><p>弹性:弹性为公共API提供了一种在不改变ABI的情况下,API随时间发展的方式.例如:在不改变ABI时,一些老预言增加基类的问题(可能不太对…)</p>
</li>
<li><p>Stabilizing the ABI: There are a ton of small details that need to be audited and improved in the code generation model, including interaction with the Swift runtime. While not specifically user-facing, the decisions here affect performance and (in some rare cases) the future evolution of Swift.</p>
</li>
<li><p>稳定ABI：有大量的细节需要在代码生成模型中进行审核和改进，包括与Swift运行时的交互。虽然不是特别面向用户，这里的决定影响性能和（在一些罕见的情况下）Swift的未来发展。</p>
</li>
<li><p>Generics improvements needed by the standard library: the standard library has a number of workarounds for language deficiencies, many of which manifest as extraneous underscored protocols and workarounds. If the underlying language deficiencies remain, they become a permanent part of the stable ABI. <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md" target="_blank" rel="external">Conditional                                            conformances</a>,<br><a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#recursive-protocol-constraints-" target="_blank" rel="external">recursive protocol requirements</a>,<br>and <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0142-associated-types-constraints.md" target="_blank" rel="external">where clauses for associated     types</a> are known to be in this category, but it’s plausible that other features will be in scope if they would be used in the standard library.</p>
</li>
<li><p>标准库需要的通用改进：标准库有多种语言缺陷的解决方法，其中许多表现为无关紧要的协议和解决方法。如果潜在的语言缺陷仍然存在，它们将成为稳定ABI的永久性部分。条件一致性，递归协议要求和其中相关类型的子句已知属于此类别，但是如果在标准库中使用其他特征，则其他特征将在范围内是合理的。</p>
</li>
<li><p>String re-evaluation: String is one of the most important fundamental types in the language. Swift 4 seeks to make strings more powerful and easier-to-use, while retaining Unicode correctness by default.</p>
</li>
<li><p>字符串重新评估：字符串是语言中最重要的基本类型之一。 Swift 4旨在使字符串更强大，更易于使用，同时在默认情况下保留Unicode正确性。</p>
</li>
<li><p>Memory ownership model: an (opt-in) Cyclone/Rust-inspired memory ownership model is highly desired by systems programmers and for other high-performance applications that want predictable and deterministic performance. This feature will fundamentally shape the ABI, from low-level language concerns such as “inout” and low-level “addressors” to its impact on the standard library. While a full memory ownership model is likely too large for Swift 4 stage 1, we need a comprehensive design to understand how it will change the ABI.<br>*内存拥有模型：（opt-in）Cyclone / Rust启发的内存拥有模式是系统程序员和其他需要可预测和确定性性能的高性能应用程序所非常需要的。这个特性将从根本上塑造ABI，从低级语言关注如“inout”和低级“addressors”到它对标准库的影响。虽然完整的内存拥有模型对于Swift 4第1阶段可能过大，但我们需要一个全面的设计来了解它将如何改变ABI。</p>
</li>
</ul>
<h2 id="Previous-releases"><a href="#Previous-releases" class="headerlink" title="Previous releases"></a>Previous releases</h2><ul>
<li><a href="releases/swift-3_0.md">Swift 3.0</a> - Released on September 13, 2016</li>
<li><a href="releases/swift-2_2.md">Swift 2.2</a> - Released on March 21, 2016</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Swfit/">Swfit</a><a href="/tags/翻译/">翻译</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/17/Swift-4-0-该来的还是要来的/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/17/Swift-4-0-该来的还是要来的/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/23/Disqus-竟然被墙了/" title="Disqus 竟然被墙了" itemprop="url">Disqus 竟然被墙了</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-09-23T01:40:06.000Z" itemprop="datePublished"> Published 2016-09-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>额,我一直是科学上网的,没有发现Disqus被墙了.<br>鉴于Disqus被墙了,现在换上多说这个国产评论,不知道好不好用,不过长得的确没有Disqus酷炫了.<br>虽然没几个评论,不过我的评论啊!~~</p>
<p>特此通告!</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/通告/">通告</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/23/Disqus-竟然被墙了/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/23/Disqus-竟然被墙了/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/11/重构-读书笔记-二/" title="重构 读书笔记(二)" itemprop="url">重构 读书笔记(二)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-09-11T09:04:19.000Z" itemprop="datePublished"> Published 2016-09-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这两天重构的第二,第三章已经读了两遍了.感觉东西太干,太实.有些的方可能是经验还达不到,明显感觉到面”huo”不开了,但是的确是大补啊,也想总结一下了,可能会有大量的原文摘录.还有些在工作中没没么相遇,以后回来再看,希望能有收获.</p>
<h1 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h1><p>第二章详细阐述了是什么为什么怎么做,其中的思辨很精彩.</p>
<h2 id="重构的定义"><a href="#重构的定义" class="headerlink" title="重构的定义"></a>重构的定义</h2><blockquote>
<p>重构(名词):对软件内部结构的一种调整,目的实在不改变软件可观察行为的前提下,提高软件的可理解性,降低其修改成本</p>
<p>重构(动词):使用一系列重构手法,在不改变软件可观察行为的前提下,调整其结构.</p>
</blockquote>
<p>共同点很明显,<strong>就是不能改变软件可观察的外观.</strong>这搞得我们程序员有点像幕后黑手,表面和平,背后暗流汹涌.还有就是不能两手都要抓,两手都要硬了.一定要遵循<strong>两顶帽子原则</strong>.原则即是:增加新功能与重构分别是两顶帽子,一次只能带一顶.</p>
<h2 id="为何重构"><a href="#为何重构" class="headerlink" title="为何重构"></a>为何重构</h2><h3 id="1-重构改进软件设计"><a href="#1-重构改进软件设计" class="headerlink" title="1.重构改进软件设计"></a>1.重构改进软件设计</h3><p>其中代码结构的流失是累积性的,这点感受太明显了,现在因为追求迭代,追求快速上架新功能,整个项目很多东西,都是快速集成,与当初搭架子的时候想的完全不一样,甚至还有一部分代码直接是粘的,对程序的思路影响更大.后面新功能想上,就很麻烦,有时候需要什么黑魔法,更别提什么性能了,在我看来这些黑魔法都是违背程序可读性与可维护性的.所以更凸显了重构的作用.</p>
<h3 id="2-重构使软件更容易理解"><a href="#2-重构使软件更容易理解" class="headerlink" title="2.重构使软件更容易理解"></a>2.重构使软件更容易理解</h3><p>这里也是要庆幸了,我没怎么接过二手代码,不过现在想想接受我的第一份代码的程序员坟头上的有几米高了(偷笑),但是重构的确可以快速提高可读性,其实中间还能提高程序的短读性,你再也不害怕,一个思路中间出去吃个饭就忘了,因为代码是在太流畅了.</p>
<h3 id="3-重构找bug-重构提高编程速度"><a href="#3-重构找bug-重构提高编程速度" class="headerlink" title="3.重构找bug,重构提高编程速度"></a>3.重构找bug,重构提高编程速度</h3><p>我的感觉其实还是bug找重构多谢,因为有的地方写不通了,才去改是很累的.至于编程速度,清晰地结构的确可以提高编程速度.</p>
<h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><h3 id="添加功能时重构"><a href="#添加功能时重构" class="headerlink" title="添加功能时重构"></a>添加功能时重构</h3><h3 id="修改bug时重构"><a href="#修改bug时重构" class="headerlink" title="修改bug时重构"></a>修改bug时重构</h3><h3 id="复审代码时重构"><a href="#复审代码时重构" class="headerlink" title="复审代码时重构"></a>复审代码时重构</h3><p>总结下就是随时重构,但是还是要注意进度的,不能重构起来没完,耽误进度.这里有个今天明天的比喻还是很形象的,重构代码是为了明天,写代码是为了今天.相信程序员还是很有忧患意识的,毕竟是个学习种群,但也不要为了明天,饿坏了今天的自己.</p>
<h2 id="重构中的难题"><a href="#重构中的难题" class="headerlink" title="重构中的难题"></a>重构中的难题</h2><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><p>这里不妄言,数据库了解的的确不多,只懂基础,不敢多说.</p>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>自己换位思想,你要是用了一个三天两头换api的三方,你会不会骂娘,尤其是你兴高采烈的觉着今天可以早下班,刚出门就让老板追回来重新配适新的api,你会不会骂娘?当然你可以保留旧接口,然后带来双倍的维护困难.即使你一直维护着新旧两套接口,改的速度快了,我们也麻烦不是.</p>
<h3 id="3-难以重构完成的设计改动-安全"><a href="#3-难以重构完成的设计改动-安全" class="headerlink" title="3.难以重构完成的设计改动(安全)"></a>3.难以重构完成的设计改动(安全)</h3><p>有时候有些东西跟安全沾边,多么笨重他也要用了,没办法数据安全太重要了.</p>
<h3 id="4-不该重构"><a href="#4-不该重构" class="headerlink" title="4.不该重构"></a>4.不该重构</h3><p>这里分时间因素与成本因素了,成本就是重构代价实在太大,不如推倒重盖.时间就是要交代码了的时间到了,就别重构,先想想饭碗吧…</p>
<h2 id="重构与设计"><a href="#重构与设计" class="headerlink" title="重构与设计"></a>重构与设计</h2><p>其实重构设计我感觉本来基本就是一回事,无非设计的目的就是减少重构罢了.还有这里我的感觉是,最好重构不要动设计模式里的东西,虽然从基本上来看可读性的确增加了,但是人有思维惯性的啊.</p>
<h2 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h2><p>重构与性能一直是个挺矛盾的,因为客观上讲重构大多是会略微降低下性能,但是重构后的代码又可以高屋建瓴,更好地提升性能.还是那个今天明天吧,从长远上看还是重构吧.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>啪啪啪啪打了这么多,这些高大上的东西可能还是吃的不透吧,但是希望在以后的编程中,抬头看到这些大神们闪耀着思维的光辉,还是能有所明悟的吧,我可是站在巨人的肚脐眼上啊!</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/读书笔记/">读书笔记</a><a href="/tags/重构/">重构</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/11/重构-读书笔记-二/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/11/重构-读书笔记-二/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/03/重构-读书笔记-一/" title="重构 读书笔记(一)" itemprop="url">重构 读书笔记(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-09-03T07:47:39.000Z" itemprop="datePublished"> Published 2016-09-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-为什么重构"><a href="#1-为什么重构" class="headerlink" title="1.为什么重构"></a>1.为什么重构</h2><p>虽然书上提到了重构中提到了可以提高理解性,但我认为重构的主要目的还是为了提高程序的延展性,降低了程序的修改成本,其中的一些思想与代码看起来真的跟艺术一样.</p>
<h2 id="2-重构离不开测试"><a href="#2-重构离不开测试" class="headerlink" title="2.重构离不开测试"></a>2.重构离不开测试</h2><p>因为重构代码是为了让代码更好地服务与我们.而不是添麻烦.所以一定要构建良好的测试方法,<strong>测试方法必须要有自我检验能力.</strong>使得重构前后程序所得到的结果保持一致.而且在重构中建议将步子放的小一些,<strong>重构技术就是以微小的步伐修改程序.</strong></p>
<h2 id="3-优秀的程序员写代码给人看"><a href="#3-优秀的程序员写代码给人看" class="headerlink" title="3.优秀的程序员写代码给人看"></a>3.优秀的程序员写代码给人看</h2><p>在我的理解,这里感觉重构过度会降低代码的理解性,因为他会分割逻辑.但是重构的确会带来条理明确的代码.(我个人认为这两条不矛盾),通过重构能够保证每次运算都是在变量的声明层,的确是易于维护.也许是我思想转不过弯来,有待后续提高.</p>
<h2 id="4-第一个实例中所运用的技巧"><a href="#4-第一个实例中所运用的技巧" class="headerlink" title="4.第一个实例中所运用的技巧"></a>4.第一个实例中所运用的技巧</h2><h3 id="1-减少跨越"><a href="#1-减少跨越" class="headerlink" title="(1)减少跨越"></a>(1)减少跨越</h3><p>将顾客电影商家三者三者联系解耦,建立了顾客-&gt;商家-&gt;电影的一对一的联系,尽量减少隔层跨越,使用商家成为顾客,电影的纽带,感觉这个模型非常像MVC模型的简化版,这也说明了设计思想是共通的.</p>
<h3 id="2-减少临时变量与修改变量名"><a href="#2-减少临时变量与修改变量名" class="headerlink" title="(2)减少临时变量与修改变量名"></a>(2)减少临时变量与修改变量名</h3><p>这里减少了大量的临时变量,减少了数据的传递,在性能上有优化但不多,主要还是为了减少传递,但是我个人认为一些便于理解的变量名还是有利于程序后续开发的,当然也可以用注释来替代.<br>同时修改刚才解耦后的变量名,这我就认为是老生常谈了,但是一个贴合变量的变量名的确是非常有用的.</p>
<h3 id="3-高屋建瓴来优化性能"><a href="#3-高屋建瓴来优化性能" class="headerlink" title="(3)高屋建瓴来优化性能"></a>(3)高屋建瓴来优化性能</h3><p>看到这里感触还是很大的,的确是大量重构之后,的确是会可能出现性能降低的问题.但是真的变得非常好解决了,高度重构的代码只需要一些很简单的方法就可以避免性能问题,甚至提升性能,的确是把复杂问题变成了多个简单问题.</p>
<h3 id="4-重构过程中的一些小技巧"><a href="#4-重构过程中的一些小技巧" class="headerlink" title="(4)重构过程中的一些小技巧"></a>(4)重构过程中的一些小技巧</h3><p>举几个例子,就比如拆分函数,需要观察函数中的相对常量,相对变量,变量可以作为返回值等,这些就不一一列举了.</p>
<h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>这本书的确是一本开卷有益的好书,第一个例子非常小,就是一个简单地大学课后题的程序,竟然就是写了50多页,的确是应了作者说的随便一个例子100多页(刚开始还真以为有点吹啊),虽然程序很小,但是透露出来的思想的确是非常的棒,这本书买的绝对是值了.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/读书笔记/">读书笔记</a><a href="/tags/重构/">重构</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/03/重构-读书笔记-一/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/03/重构-读书笔记-一/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/12/编程之美-1的数目/" title="编程之美-1的数目" itemprop="url">编程之美-1的数目</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-04-12T12:55:38.000Z" itemprop="datePublished"> Published 2016-04-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="问题-1的数目"><a href="#问题-1的数目" class="headerlink" title="问题:1的数目"></a>问题:1的数目</h2><blockquote><p>给定一个十进制正整数N,写下从一开始到N的所有整数,然后数其中出现的所有1的个数.其中11算两个,111算三个</p>
<p>1.给正整数N,写代码计算1的个数.<br>2.满足飞f(N) = N 的最大数是多少?</p>
</blockquote>
<h3 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h3><p>对从1到N的每个数字进行遍历,其中对每个数字的每个位数进行遍历<br>对每个数字位数遍历的代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">theNumberCount = 0;</div><div class="line">while (n != 0)</div><div class="line">&#123;</div><div class="line">     theNumberCount += (n % 10 == 1) ? 1 : 0;</div><div class="line">     n/=10;</div><div class="line">&#125;//这里自己使用if写的,和人家书上一比真是自惭形秽....</div></pre></td></tr></table></figure><br>这里时间复杂度为= N <em> lgN = 循环数字 </em> 循环位数</p>
<h3 id="牛逼的思路"><a href="#牛逼的思路" class="headerlink" title="牛逼的思路"></a><strong>牛逼的思路</strong></h3><p>感觉真正牛逼的思路一般都不会是从普通角度出发的,这次计算一的个数,我们只考虑位次.只需要考虑N在每个位置上出现的次数<br>假设当N = 145<br>N在个位上出现了 345 / 10  + 1= 35次<br>N在十位上出现了 345 / 10 / 10 * 10 = 30次<br>N在百位上出现了  100次</p>
<p>可得出规律<br>其中核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">iCount = 0;</div><div class="line"></div><div class="line">iFactor = 1;</div><div class="line"></div><div class="line">iLowerNum = 0;</div><div class="line"></div><div class="line">iCurrNum = 0;</div><div class="line"></div><div class="line">iHigherNum = 0;</div><div class="line"></div><div class="line">while(n / iFactor != 0)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">iLowerNum = n - (n / iFactor) * iFactor;</div><div class="line"></div><div class="line">iCurrNum = (n / iFactor) % 10;</div><div class="line"></div><div class="line">iHigherNum = n / (iFactor * 10);</div><div class="line"></div><div class="line">switch(iCurrNum)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">case 0:</div><div class="line"></div><div class="line">iCount += iHigherNum * iFactor;</div><div class="line"></div><div class="line">break;</div><div class="line"></div><div class="line">case 1:</div><div class="line"></div><div class="line">iCount += iHigherNum * iFactor + iLowerNum + 1;</div><div class="line"></div><div class="line">break;</div><div class="line"></div><div class="line">default:</div><div class="line"></div><div class="line">iCount += (iHigherNum + 1) * iFactor;</div><div class="line"></div><div class="line">break;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">iFactor *= 10;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法只要分析N就可以得到f（N），避开了从1到N的遍历，输入长度为Len的数字N的时间复杂度为O（Len），即为O（ln（n）/ln（10）+1）。</p>
<h3 id="问题2的思路"><a href="#问题2的思路" class="headerlink" title="问题2的思路"></a>问题2的思路</h3><p>这就要拿起以前上大学的数学了,这里归根结底还是个求就极限的问题 通过上一个程序可推测N = N * N的指数(n-1),也就可以得出指数在等于11的时候N超过上届一点点点点,然后就是恶心的遍历时间了,这个便利比较简单代码我就不写了.<br>最后得到N = 1111111110 (别数了9个1)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/读书笔记/">读书笔记</a><a href="/tags/编程之美/">编程之美</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/04/12/编程之美-1的数目/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/04/12/编程之美-1的数目/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/16/寻找单身狗-二/" title="寻找单身狗(二)" itemprop="url">寻找单身狗(二)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-03-16T12:01:46.000Z" itemprop="datePublished"> Published 2016-03-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>然而算法这个东西撇开实际操作的话,就没有什么意义了,这让我想到赶快找到一个案例来快速的使用上我们的算法,也让我打开了一本中途弃读的书.(以前感觉自己段位不够,现在可能也不够….)</p>
<hr>
<p>其中问题如下:<br><blockquote><p>有很多服务器存储数据，假设一个机器仅存储一个标号为ID的记录，假设机器总量在10亿以下且ID是小于10亿的整数，假设每份数据保存两个备份，这样就有两个机器存储了同样的数据。</p>
<p>问题是：<br>1.假设在某个时间得到一个数据文件ID的列表，是否能快速地找出表中仅出现一次的ID？即快速找出出现故障的机器存储的数据ID。</p>
<p>2.如果有两台机器出现故障呢？（假设存储同一份数据的两台机器不会同时出现故障，即列表中缺少的是两个不等的ID）</p>
<footer><strong>快速找出故障机器</strong><cite>编程之美</cite></footer></blockquote><br>我们回顾一下上一篇单身狗的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (array.length == 0)</div><div class="line">return -1;</div><div class="line">int x = 0;</div><div class="line">for (int i = 0; i &lt; array.count; i++) &#123;</div><div class="line">x = x ^ array[i];</div><div class="line">&#125;</div><div class="line">return x;</div></pre></td></tr></table></figure><br>这里我们一眼就能看出我们的代码非常适合问题一,这个也就是书上的思路三的一部分,他已经是一个相对较好的解决方案了.我们现在就来对比一下书上的其他思路.</p>
<hr>
<h2 id="对比-优化-升级"><a href="#对比-优化-升级" class="headerlink" title="对比,优化,升级"></a>对比,优化,升级</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>遍历序列,引入第二个数组 ,来记录每个id的出现的次数,遍历完毕后,再在整个数组上查询计数为1的那只单身狗.这样来看时间复杂度为O(N),空间复杂度为O(N).(空间复杂度的思想很重要~)<br>当然在这种情况问题二易得出.</p>
<hr>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路二是思路一的升级版,就是优化他的计数数组,使用哈希表,每当一个数字出现两次,就从表中删除掉这些成对出现的数(FFF),这样的确可以有效节约空间复杂度,但是从最坏情况来看,时间复杂度,空间复杂度依然是O(N).<br>当然在这种情况问题二也易得出.</p>
<hr>
<h3 id="思路三-也就是我们的思路"><a href="#思路三-也就是我们的思路" class="headerlink" title="思路三(也就是我们的思路)"></a>思路三(也就是我们的思路)</h3><p>因为异或只需要占用有限的存储空间,所以我们可以轻易的将空间复杂度降低为O(n),这里也体现了我们的高瞻远瞩~<br>但是要解决问题二我们就相对复杂一些,这里我们可以做分类讨论,因为若是a=b,则我们可以通过求和的方式得出.若a!=b 则我们可以则a^b其中某一位上为1,也可通过数学方法的出a,b.</p>
<hr>
<h3 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h3><p>这里我认为是对思路三的优化,直接预存ID的和,与ID的乘积(还提供了平方差的思路),然后不需要分类讨论就可以快速得到a,b的值.(而且感觉也脱离的只能寻找1或者2个数的困境???存疑)</p>
<hr>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1.个人感觉位计算在很多地方还是有奇效的,希望以后自己多注意吧,不知道单身狗还有没有(三),有的话准备继续整理下位运算的案例.<br>2.然后就是程序设计要有算法追求还是建议一步一步来,优秀的代码都是有思维路线的,感觉想要一步到位,容易扯着蛋.<br>3.近期也拿起来了一些以前买的书(这都是欠的债啊),希望以后多写点读书总结.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/思路拓展/">思路拓展</a><a href="/tags/读书笔记/">读书笔记</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/16/寻找单身狗-二/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/16/寻找单身狗-二/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/14/每日一题-1/" title="寻找单身狗(一)" itemprop="url">寻找单身狗(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="YaronYang" target="_blank" itemprop="author">YaronYang</a>
		
  <p class="article-time">
    <time datetime="2016-03-14T14:38:25.000Z" itemprop="datePublished"> Published 2016-03-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>群里有个每日一题是这样的:<br><blockquote><p>一个Int型数组，里面的每一个数都是成双成对的，只有一个数是单身狗，找出这个数，算法复杂度&lt;= O(n)</p>
<footer><strong>群主大大</strong></footer></blockquote></p>
<h2 id="千里之行属于足下"><a href="#千里之行属于足下" class="headerlink" title="千里之行属于足下"></a>千里之行属于足下</h2><p>,刚开始拿到这个问题,我直接没去关注后面的算法复杂度,因为我感觉解决问题遵循的应该是这么一个原则:<strong>拿到一个问题刚开始不要去思考什么高等方案,而是先找出能够解决的方案</strong>,按照正常思路我一下就得到了这个问题的基础解.</p>
<h3 id="思路一穷举"><a href="#思路一穷举" class="headerlink" title="思路一穷举"></a>思路一穷举</h3><p>正常思想无非就是就是双层循环,然后每个数之间进行对比,然后找到那个单身狗,然后跳出循环.这里的代码就不贴了,应该大家都会的,但是明显不符合题意,这里的时间复杂度应该是O(n的平方)</p>
<p>然后我就开始进入优化思考了,然后习惯性的把思路带入了那些比较经典的排序查找,但是仔细一思索,还是按照这个思路来,怎么也无法将复杂度降到O(n),在这个时候群里的其他朋友站了出来</p>
<h3 id="思路二位运算"><a href="#思路二位运算" class="headerlink" title="思路二位运算"></a>思路二位运算</h3><p>这群里的一位大神给出的答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int x = array[0];</div><div class="line">for (int i = 1; i &lt; array.count; i++) &#123;</div><div class="line">x = x ^ array[i];</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;%li&quot;, x);</div></pre></td></tr></table></figure><br>长时间不接触位运算,乍一看还是有点糊涂的,但是看了会大致明白了,是利用了<strong>问题的特性</strong>,都是双数,单身狗只有一只,这样做位运算单身狗的确无所遁形,而且时间复杂度也降落到了O(n),精彩的解答.</p>
<h3 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="查漏补缺"></a>查漏补缺</h3><p>虽然上面的代码看起来已经非常好了,但其实还是有些问题的,那就是没有考虑异常情况,这里数组中没有元素,数组中只有一个元素的情况都是有可能发生的,(这让我想起了独自一人在公司加班到深夜的程序员形象),所以代码最后成型应该是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (array.length == 0)</div><div class="line">  return -1;</div><div class="line">int x = 0;</div><div class="line">for (int i = 0; i &lt; array.count; i++) &#123;</div><div class="line">x = x ^ array[i];</div><div class="line">&#125;</div><div class="line">return x;</div></pre></td></tr></table></figure><br>这样形成的代码应该就是算法的较优解了.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/思路拓展/">思路拓展</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/14/每日一题-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/14/每日一题-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/思路拓展/" title="思路拓展">思路拓展<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/重构/" title="重构">重构<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/通告/" title="通告">通告<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Swfit/" title="Swfit">Swfit<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/编程之美/" title="编程之美">编程之美<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Swfit/" style="font-size: 10px;">Swfit</a> <a href="/tags/思路拓展/" style="font-size: 13.33px;">思路拓展</a> <a href="/tags/算法/" style="font-size: 16.67px;">算法</a> <a href="/tags/编程之美/" style="font-size: 10px;">编程之美</a> <a href="/tags/翻译/" style="font-size: 10px;">翻译</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a> <a href="/tags/通告/" style="font-size: 10px;">通告</a> <a href="/tags/重构/" style="font-size: 13.33px;">重构</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m YaronYang ,A iOS Developer. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="YaronYang">YaronYang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
